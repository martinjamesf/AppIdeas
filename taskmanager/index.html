<!DOCTYPE html>
<html data-theme="dark">

<head>
  <meta charset="UTF-8">
  <title>Task Manager</title>
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest">
  <style>
    td input,
    td select {
      width: 100%;
      box-sizing: border-box;
    }

    td a {
      color: var(--pico-primary);
      cursor: pointer;
    }

    .modal {
      display: none;
      position: fixed;
      top: 10%;
      left: 50%;
      transform: translate(-50%, 0);
      background: var(--pico-background);
      padding: 1rem;
      border: 1px solid var(--pico-border-color);
      z-index: 10;
      width: 90%;
      max-width: 500px;
    }

    .modal.active {
      display: block;
    }

    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.5);
      z-index: 5;
    }

    .overlay.active {
      display: block;
    }

    .btn-blue {
      background-color: var(--pico-primary);
      color: white;
    }

    .sortable-placeholder {
      background: rgba(255, 255, 255, 0.1);
      height: 2rem;
      border: 1px dashed var(--pico-primary);
    }
  </style>
</head>

<body>
  <main class="container">
    <h1>Task Manager</h1>

    <div class="grid">
      <div>
        <button class="btn-blue" onclick="toggleEditMode()" id="editToggle">Edit</button>
        <select id="workflowSelect">
          <option disabled selected>Select Workflow</option>
          <option value="risk">Risk Policy Opening</option>
          <option value="wealth">Wealth Account Opening</option>
        </select>
        <button class="btn-blue" onclick="applyWorkflow()">Apply Workflow</button>
      </div>
      <div>
        <button class="btn-blue" onclick="downloadJSON()">Download JSON</button>
        <input type="file" onchange="uploadJSON(event)">
      </div>
    </div>

    <table id="taskTable">
      <thead>
        <tr>
          <th>#</th>
          <th>Task Name</th>
          <th>Type</th>
          <th>Task Creation Sequence</th>
        </tr>
      </thead>
      <tbody id="taskBody">
        <!-- Tasks will go here -->
      </tbody>
    </table>
  </main>

  <!-- Modal Editor -->
  <div class="overlay" id="modalOverlay" onclick="closeModal()"></div>
  <div class="modal" id="taskModal">
    <h3>Edit Task</h3>
    <label>Task Name: <input id="modalTaskName" /></label>
    <label>Task Type:
      <select id="modalTaskType">
        <option>Independent</option>
        <option>Sequential</option>
        <option>Parallel</option>
      </select>
    </label>
    <label>Task Creation Sequence:
      <input id="modalTaskSequence" />
    </label>
    <button class="btn-blue" onclick="saveModal()">Save</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script>
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    let editMode = false;
    let modalIndex = null;

    const taskBody = document.getElementById('taskBody');
    const overlay = document.getElementById('modalOverlay');
    const modal = document.getElementById('taskModal');

    function renderTasks() {
      taskBody.innerHTML = '';
      tasks.forEach((task, i) => {
        const row = document.createElement('tr');
        const numberCell = document.createElement('td');
        numberCell.textContent = ''; // populated later
        row.appendChild(numberCell);

        const nameCell = document.createElement('td');
        if (editMode) {
          const input = document.createElement('input');
          input.value = task.name;
          input.oninput = e => { task.name = e.target.value; saveTasks(); };
          nameCell.appendChild(input);
        } else {
          const link = document.createElement('a');
          link.textContent = task.name;
          link.onclick = () => openModal(i);
          nameCell.appendChild(link);
        }
        row.appendChild(nameCell);

        const typeCell = document.createElement('td');
        if (editMode) {
          const select = document.createElement('select');
          ['Independent', 'Sequential', 'Parallel'].forEach(type => {
            const option = new Option(type, type, false, task.type === type);
            select.appendChild(option);
          });
          select.onchange = e => { task.type = e.target.value; saveTasks(); };
          typeCell.appendChild(select);
        } else {
          typeCell.textContent = task.type;
        }
        row.appendChild(typeCell);

        const seqCell = document.createElement('td');
        const input = document.createElement('input');
        input.value = task.sequence || '';
        input.oninput = e => { task.sequence = e.target.value; saveTasks(); };
        seqCell.appendChild(input);
        row.appendChild(seqCell);

        taskBody.appendChild(row);
      });

      updateTaskNumbers();
      saveTasks();
    }

    function toggleEditMode() {
      editMode = !editMode;
      document.getElementById('editToggle').textContent = editMode ? 'Save' : 'Edit';
      renderTasks();
    }

    function updateTaskNumbers() {
      let num = 1;
      for (let i = 0; i < tasks.length;) {
        const row = taskBody.children[i];
        const current = tasks[i];
        if (current.type === 'Independent') {
          row.children[0].textContent = num++;
          i++;
        } else if (current.type === 'Sequential') {
          let j = i;
          let count = 1;
          while (j < tasks.length && tasks[j].type === 'Sequential') {
            taskBody.children[j].children[0].textContent = `${num}.${count++}`;
            j++;
          }
          num++;
          i = j;
        } else if (current.type === 'Parallel') {
          let j = i;
          while (j < tasks.length && tasks[j].type === 'Parallel') {
            taskBody.children[j].children[0].textContent = `${num}`;
            j++;
          }
          num++;
          i = j;
        }
      }
    }

    function openModal(index) {
      modalIndex = index;
      const task = tasks[index];
      document.getElementById('modalTaskName').value = task.name;
      document.getElementById('modalTaskType').value = task.type;
      document.getElementById('modalTaskSequence').value = task.sequence || '';
      modal.classList.add('active');
      overlay.classList.add('active');
    }

    function closeModal() {
      modal.classList.remove('active');
      overlay.classList.remove('active');
    }

    function saveModal() {
      const task = tasks[modalIndex];
      task.name = document.getElementById('modalTaskName').value;
      task.type = document.getElementById('modalTaskType').value;
      task.sequence = document.getElementById('modalTaskSequence').value;
      closeModal();
      renderTasks();
    }

    function applyWorkflow() {
      const val = document.getElementById('workflowSelect').value;
      if (val === 'risk') {
        tasks.push(
          { name: 'Open Case', type: 'Independent' },
          { name: 'Closing', type: 'Sequential' },
          { name: 'Business Submitted', type: 'Sequential' },
          { name: 'Underwriting', type: 'Parallel' },
          { name: 'Delivery', type: 'Parallel' },
          { name: 'Business In-force', type: 'Independent' }
        );
      } else if (val === 'wealth') {
        tasks.push(
          { name: 'Client Discovery', type: 'Independent' },
          { name: 'Portfolio Design', type: 'Sequential' },
          { name: 'Client Approval', type: 'Sequential' },
          { name: 'Account Opening', type: 'Parallel' },
          { name: 'Funding', type: 'Parallel' },
          { name: 'Investment Execution', type: 'Independent' }
        );
      }
      renderTasks();
    }

    function downloadJSON() {
      const blob = new Blob([JSON.stringify(tasks, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "tasks.json";
      a.click();
    }

    function uploadJSON(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          tasks = JSON.parse(e.target.result);
          renderTasks();
        } catch {
          alert('Invalid JSON');
        }
      };
      reader.readAsText(file);
    }

    function saveTasks() {
      localStorage.setItem('tasks', JSON.stringify(tasks));
    }

    new Sortable(taskBody, {
      animation: 150,
      onEnd: function (evt) {
        const [moved] = tasks.splice(evt.oldIndex, 1);
        tasks.splice(evt.newIndex, 0, moved);
        renderTasks();
      }
    });

    renderTasks();
  </script>
</body>

</html>